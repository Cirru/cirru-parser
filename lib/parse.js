// Generated by CoffeeScript 1.6.3
var error_message, fs, match, parse, path, prettyjson, protos, render, repeat, stringify, type, wrap_parse, _ref;

fs = require('fs');

path = require('path');

match = require('coffee-pattern').match;

_ref = require('./util'), type = _ref.type, render = _ref.render, stringify = _ref.stringify;

protos = require('./states').protos;

prettyjson = require('prettyjson');

parse = function(text) {
  var ast, buffer, caret, clear_buffer, folding, indent, pushStack, put_error, stack;
  caret = protos.caret["new"]();
  buffer = protos.buffer["new"]();
  stack = protos.stack["new"]();
  indent = protos.indent["new"]();
  ast = protos.ast["new"]();
  folding = protos.folding["new"]();
  pushStack = function(object) {
    return stack.push({
      name: caret.wrap(object)
    });
  };
  clear_buffer = function() {
    if (buffer.text != null) {
      ast.push(buffer.out());
    }
    if (stack.now === 'buffer') {
      return stack.pop();
    }
  };
  put_error = function(name) {
    return ast.tree.error = error_message(caret.wrap({
      text: name
    }), text);
  };
  ast.nest();
  text.split('').forEach(function(char) {
    var normal_pattern;
    normal_pattern = function() {
      return match(char, {
        '"': function() {
          return pushStack('quote');
        },
        ' ': function() {},
        $: function() {
          ast.nest();
          return folding.add(caret.wrap({
            level: indent.level
          }));
        },
        '\n': function() {
          clear_buffer();
          return pushStack('indent');
        },
        '(': function() {
          clear_buffer();
          return ast.nest();
        },
        ')': function() {
          clear_buffer();
          return ast.ease();
        }
      }, void 0, function() {
        pushStack('buffer');
        return buffer.add(char);
      });
    };
    match(stack.now, {
      empty: normal_pattern,
      buffer: function() {
        return match(char, {
          ' ': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            clear_buffer();
            return pushStack('indent');
          },
          ')': function() {
            clear_buffer();
            ast.ease();
            return stack.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      escape: function() {
        buffer.add(char);
        return stack.pop();
      },
      quote: function() {
        return match(char, {
          '\\': function() {
            return pushStack('escape');
          },
          '"': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            return put_error('quote not closed');
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      indent: function() {
        return match(char, {
          ' ': function() {
            return indent.count();
          },
          '\n': function() {
            return indent.skip();
          }
        }, void 0, function() {
          var pop_folding, step;
          step = indent.read();
          (pop_folding = function() {
            var out;
            if (folding.exists && (indent.level <= folding.level)) {
              out = folding.pop();
              ast.ease();
              return pop_folding();
            }
          })();
          match(step.type, {
            indent: function() {
              var _i, _ref1, _results;
              return (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.nest();
              });
            },
            dedent: function() {
              var _i, _ref1, _results;
              (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.ease();
              });
              return ast.newline();
            },
            plain: function() {
              return ast.newline();
            }
          });
          stack.pop();
          return normal_pattern();
        });
      }
    });
    return match(char, {
      '\n': function() {
        return caret.newline();
      }
    }, void 0, function() {
      return caret.forward();
    });
  });
  if (buffer.text != null) {
    clear_buffer();
  }
  while (folding.exists) {
    folding.pop();
    ast.ease();
  }
  if (stack.now === 'quote') {
    put_error('quote at end');
  }
  return ast.tree;
};

wrap_parse = function(filename) {
  var fullpath, text;
  fullpath = path.join(process.env.PWD, "./test/" + filename);
  text = fs.readFileSync(fullpath, 'utf8');
  return {
    path: fullpath,
    ast: parse(text),
    script: text.split('\n')
  };
};

exports.parse = wrap_parse;

repeat = function(char, n) {
  var _i, _results;
  return (function() {
    _results = [];
    for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).map(function() {
    return char;
  }).join('');
};

error_message = function(error, text) {
  var cursor, info, lines;
  info = [];
  lines = text.split('\n');
  info.push('');
  info.push(lines[error.y]);
  cursor = repeat('~', error.x);
  if (cursor.length > 0) {
    cursor = cursor.slice(0, -1) + '^';
  }
  cursor += '~~~~~';
  info.push(cursor);
  info.push("@ line " + (error.y + 1) + ": " + error.text);
  return info.join('\n');
};

/*
//@ sourceMappingURL=parse.map
*/
