// Generated by CoffeeScript 1.6.3
var fs, match, parse, path, prettyjson, protos, render, stringify, type, wrap_parse, _ref;

fs = require('fs');

path = require('path');

match = require('coffee-pattern').match;

_ref = require('./util'), type = _ref.type, render = _ref.render, stringify = _ref.stringify;

protos = require('./states').protos;

prettyjson = require('prettyjson');

parse = function(text) {
  var ast, buffer, caret, clear_buffer, folding, indent, pushStack, stack;
  caret = protos.caret["new"]();
  buffer = protos.buffer["new"]();
  stack = protos.stack["new"]();
  indent = protos.indent["new"]();
  ast = protos.ast["new"]();
  folding = protos.folding["new"]();
  pushStack = function(object) {
    return stack.push(caret.wrap(object));
  };
  clear_buffer = function() {
    if (buffer.text != null) {
      ast.push(buffer.out());
    }
    if (stack.now === 'buffer') {
      return stack.pop();
    }
  };
  ast.nest();
  text.split('').forEach(function(char) {
    var normal_pattern;
    normal_pattern = function() {
      return match(char, {
        '"': function() {
          return pushStack({
            name: 'quote'
          });
        },
        ' ': function() {},
        $: function() {
          ast.nest();
          return folding.add(caret.wrap({
            level: indent.level
          }));
        },
        '\n': function() {
          clear_buffer();
          return pushStack({
            name: 'indent'
          });
        },
        '(': function() {
          clear_buffer();
          return ast.nest();
        }
      }, void 0, function() {
        pushStack({
          name: 'buffer'
        });
        return buffer.add(char);
      });
    };
    match(stack.now, {
      empty: normal_pattern,
      buffer: function() {
        return match(char, {
          ' ': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            clear_buffer();
            return pushStack({
              name: 'indent'
            });
          },
          ')': function() {
            clear_buffer();
            ast.ease();
            return stack.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      escape: function() {
        buffer.add(char);
        return stack.pop();
      },
      quote: function() {
        return match(char, {
          '\\': function() {
            return pushStack({
              name: 'escape'
            });
          },
          '"': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            throw new Error('quote not closed');
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      indent: function() {
        return match(char, {
          ' ': function() {
            return indent.count();
          },
          '\n': function() {
            return indent.skip();
          }
        }, void 0, function() {
          var pop_folding, step;
          step = indent.read();
          (pop_folding = function() {
            var out;
            if (folding.exists && (indent.level <= folding.level)) {
              out = folding.pop();
              ast.ease();
              return pop_folding();
            }
          })();
          match(step.type, {
            indent: function() {
              var _i, _ref1, _results;
              return (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.nest();
              });
            },
            dedent: function() {
              var _i, _ref1, _results;
              (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.ease();
              });
              return ast.newline();
            },
            plain: function() {
              return ast.newline();
            }
          });
          stack.pop();
          return normal_pattern();
        });
      }
    });
    return match(char, {
      '\n': function() {
        return caret.newline();
      }
    }, void 0, function() {
      return caret.forward();
    });
  });
  if (buffer.text != null) {
    clear_buffer();
  }
  while (folding.exists) {
    folding.pop();
    ast.ease();
  }
  return ast.tree;
};

wrap_parse = function(filename) {
  var fullpath, text;
  fullpath = path.join(process.env.PWD, "./test/" + filename);
  text = fs.readFileSync(fullpath, 'utf8');
  return {
    path: fullpath,
    ast: parse(text),
    script: text.split('\n')
  };
};

exports.parse = wrap_parse;

/*
//@ sourceMappingURL=parse.map
*/
