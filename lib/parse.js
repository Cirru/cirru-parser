// Generated by CoffeeScript 1.6.3
var Buffer, Caret, Stack, fs, match, parse, path, print, tokenize, type, wrap_parse, _ref,
  __slice = [].slice;

fs = require('fs');

path = require('path');

match = require('coffee-pattern').match;

type = require('./util').type;

_ref = require('./states'), Caret = _ref.Caret, Buffer = _ref.Buffer, Stack = _ref.Stack;

print = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return console.log.apply(console, args);
};

tokenize = function(text) {
  var buffer, caret, pushStack, pushTokens, stack, tokens;
  caret = new Caret;
  buffer = new Buffer;
  stack = new Stack;
  tokens = [];
  pushStack = function(object) {
    return stack.push(caret.wrap(object));
  };
  pushTokens = function(object) {
    return tokens.push(caret.wrap(object));
  };
  text.split('').forEach(function(char) {
    var normal_pattern;
    normal_pattern = function() {
      return match(char, {
        '"': function() {
          return pushStack({
            name: 'quote'
          });
        },
        ' ': function() {},
        '\n': function() {},
        '(': function() {
          pushStack({
            name: 'bracket'
          });
          pushTokens({
            bracket: 'more'
          });
          return match(buffer.text != null, true, function() {
            return pushTokens({
              text: buffer.out()
            });
          });
        }
      }, void 0, function() {
        pushStack({
          name: 'buffer'
        });
        return buffer.add(char);
      });
    };
    console.log(':::', stack.now, char);
    match(stack.now, {
      empty: normal_pattern,
      bracket: normal_pattern,
      buffer: function() {
        return match(char, {
          ' ': function() {
            pushTokens({
              text: buffer.out()
            });
            return stack.pop();
          },
          '\n': function() {
            return pushTokens({
              text: buffer.out()
            });
          },
          ')': function() {
            pushTokens({
              text: buffer.out()
            });
            pushTokens({
              bracket: 'less'
            });
            return stack.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      escape: function() {
        return buffer.add(char);
      },
      quote: function() {
        return match(char, {
          '\\': function() {
            return pushStack({
              name: 'escape'
            });
          },
          '"': function() {
            pushTokens({
              text: buffer.out()
            });
            return stack.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      }
    });
    return match(char, {
      '\n': function() {
        return caret.newline();
      }
    }, void 0, function() {
      return caret.forward();
    });
  });
  return tokens;
};

parse = function(tokens) {
  return tokens;
};

wrap_parse = function(filename) {
  var fullpath, text;
  fullpath = path.join(process.env.PWD, "./test/" + filename);
  text = fs.readFileSync(fullpath, 'utf8');
  return {
    path: fullpath,
    ast: parse(tokenize(text))
  };
};

exports.parse = wrap_parse;

/*
//@ sourceMappingURL=parse.map
*/
