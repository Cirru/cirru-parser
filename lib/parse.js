// Generated by CoffeeScript 1.6.3
var error_message, fs, match, parse, path, protos, repeat, stringify, type, wrap_parse, _ref;

fs = require('fs');

path = require('path');

match = require('coffee-pattern').match;

_ref = require('./util'), type = _ref.type, stringify = _ref.stringify;

protos = require('./states').protos;

parse = function(file) {
  var ast, brackets, buffer, caret, check_bracket, clear_buffer, folding, indent, pushStack, put_error, stack;
  caret = protos.caret["new"]();
  buffer = protos.buffer["new"]();
  stack = protos.stack["new"]();
  indent = protos.indent["new"]();
  ast = protos.ast["new"]();
  folding = protos.folding["new"]();
  brackets = protos.brackets["new"]();
  pushStack = function(object) {
    return stack.push({
      name: caret.wrap(object)
    });
  };
  clear_buffer = function() {
    if (buffer.text != null) {
      ast.push(caret.wrap({
        text: buffer.out(),
        file: file
      }));
    }
    if (stack.now === 'buffer') {
      return stack.pop();
    }
  };
  put_error = function(name) {
    return ast.errors.push(error_message(caret.wrap({
      text: name,
      file: file
    })));
  };
  check_bracket = function() {
    if (brackets.count > 0) {
      put_error('bracket not closed');
    } else if (brackets.count < 0) {
      put_error('too many close bracket');
    }
    return brackets.end();
  };
  ast.nest();
  file.text.split('').forEach(function(char) {
    var normal_pattern;
    normal_pattern = function() {
      return match(char, {
        '"': function() {
          return pushStack('quote');
        },
        ' ': function() {},
        $: function() {
          ast.nest();
          return folding.add(caret.wrap({
            level: indent.level
          }));
        },
        '\n': function() {
          clear_buffer();
          pushStack('indent');
          return check_bracket();
        },
        '(': function() {
          clear_buffer();
          ast.nest();
          return brackets.add();
        },
        ')': function() {
          clear_buffer();
          ast.ease();
          return brackets.pop();
        }
      }, void 0, function() {
        pushStack('buffer');
        return buffer.add(char);
      });
    };
    match(stack.now, {
      empty: normal_pattern,
      buffer: function() {
        return match(char, {
          ' ': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            clear_buffer();
            pushStack('indent');
            return check_bracket();
          },
          ')': function() {
            clear_buffer();
            ast.ease();
            stack.pop();
            return brackets.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      escape: function() {
        buffer.add(char);
        return stack.pop();
      },
      quote: function() {
        return match(char, {
          '\\': function() {
            return pushStack('escape');
          },
          '"': function() {
            clear_buffer();
            return stack.pop();
          },
          '\n': function() {
            put_error('quote not closed');
            clear_buffer();
            return stack.pop();
          }
        }, void 0, function() {
          return buffer.add(char);
        });
      },
      indent: function() {
        return match(char, {
          ' ': function() {
            return indent.count();
          },
          '\n': function() {
            return indent.skip();
          }
        }, void 0, function() {
          var pop_folding, step;
          step = indent.read();
          (pop_folding = function() {
            var out;
            if (folding.exists && (indent.level <= folding.level)) {
              out = folding.pop();
              ast.ease();
              return pop_folding();
            }
          })();
          match(step.type, {
            indent: function() {
              var _i, _ref1, _results;
              return (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.nest();
              });
            },
            dedent: function() {
              var _i, _ref1, _results;
              (function() {
                _results = [];
                for (var _i = 1, _ref1 = step.step; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; 1 <= _ref1 ? _i++ : _i--){ _results.push(_i); }
                return _results;
              }).apply(this).map(function() {
                return ast.ease();
              });
              return ast.newline();
            },
            plain: function() {
              return ast.newline();
            }
          });
          stack.pop();
          return normal_pattern();
        });
      }
    });
    return match(char, {
      '\n': function() {
        return caret.newline();
      }
    }, void 0, function() {
      return caret.forward();
    });
  });
  if (buffer.text != null) {
    clear_buffer();
  }
  while (folding.exists) {
    folding.pop();
    ast.ease();
  }
  if (stack.now === 'quote') {
    put_error('quote at end');
  }
  check_bracket();
  return ast;
};

wrap_parse = function(filepath) {
  var file, text;
  text = fs.readFileSync(filepath, 'utf8');
  file = {
    path: filepath,
    text: text
  };
  return parse(file);
};

repeat = function(char, n) {
  var _i, _results;
  if (n > 1) {
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= n ? _i <= n : _i >= n; 1 <= n ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function() {
      return char;
    }).join('');
  } else if (n === 1) {
    return char;
  } else {
    return '';
  }
};

error_message = function(error) {
  var cursor, info, lines;
  info = [];
  lines = error.file.text.split('\n');
  info.push('');
  info.push("âœ— " + error.file.path + ": " + (error.y + 1));
  info.push(lines[error.y]);
  cursor = repeat(' ', error.x);
  cursor = cursor.slice(0, -1) + '^ ' + error.text;
  info.push(cursor, '');
  return info.join('\n');
};

exports.parse = wrap_parse;

exports.error = error_message;

/*
//@ sourceMappingURL=parse.map
*/
