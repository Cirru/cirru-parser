// Generated by CoffeeScript 1.4.0
var arr$, count, gen_table, log, nest_in, nest_table, num$, obj$, parse, str$, tokenize;

log = console.log;

Array.prototype.__defineGetter__('last', function() {
  return this[this.length - 1];
});

Array.prototype.__defineSetter__('last', function(value) {
  return this[this.length - 1] = value;
});

str$ = function(x) {
  return typeof x === 'string';
};

arr$ = Array.isArray;

obj$ = function(x) {
  return (!(arr$(x))) && (typeof x === 'object');
};

num$ = function(x) {
  return !(Number.isNaN(x));
};

exports.tokenize = tokenize = function(line) {
  var raw, res, ret, sign, str;
  raw = line.text;
  str = "(" + line.text + ")";
  res = str.replace(/\"/g, '\\"').replace(/\[/g, '[').replace(/\]/g, ']').replace(/([^\(\)\s]+)/g, '"$1",').replace(/\(/g, '[').replace(/\)/g, ']').replace(/\,\s*]/g, ']').replace(/\]\s*\[/g, '],[').replace(/\]\s*\[/g, '],[').replace(/\]\s*\"/g, '],"');
  try {
    ret = JSON.parse(res);
    (sign = function(ret) {
      return ret.map(function(item) {
        if (arr$(item)) {
          item.line = line.n;
          return sign(item);
        }
      });
    })(ret);
    return ret;
  } catch (err) {
    log('Error occured at line #{line.n}:');
    log(raw);
    log(res);
    throw err;
  }
};

count = function(n) {
  return Number((n / 2).toFixed());
};

gen_table = function(prev, curr, index) {
  var line, n, res;
  curr = curr.trimRight();
  n = count(curr.match(/^\s*/)[0].length);
  line = index + 1;
  res = tokenize({
    text: curr.trim(),
    n: line
  });
  res.line = line;
  res.indent = n;
  prev.push(res);
  return prev;
};

nest_in = function(list, item) {
  if (item.indent === 0) {
    delete item.indent;
    return list.push(item);
  } else {
    if (!((list.last != null) && (arr$(list.last)))) {
      list.push([]);
    }
    item.indent -= 1;
    return nest_in(list.last, item);
  }
};

nest_table = function(table) {
  var current_line, ret;
  ret = [];
  current_line = 0;
  table.forEach(function(line) {
    return nest_in(ret, line);
  });
  return ret;
};

exports.parse = parse = function(content) {
  var lines, ret, table;
  lines = content.split('\n');
  table = lines.reduce(gen_table, []);
  return ret = {
    code: lines,
    tree: nest_table(table)
  };
};
