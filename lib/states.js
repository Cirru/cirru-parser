// Generated by CoffeeScript 1.6.3
var proto;

proto = {
  "new": function(object) {
    var child, key, value;
    child = {};
    child.__proto__ = this;
    for (key in object) {
      value = object[key];
      child[key] = value;
    }
    if (typeof child.init === "function") {
      child.init();
    }
    return child;
  }
};

exports.protos = {
  caret: proto["new"]({
    init: function() {
      this.x = 0;
      return this.y = 0;
    },
    forward: function() {
      return this.x += 1;
    },
    newline: function() {
      this.y += 1;
      return this.x = 0;
    },
    wrap: function(object) {
      object.x = this.x;
      object.y = this.y;
      return object;
    }
  }),
  buffer: proto["new"]({
    init: function() {
      return this.text = null;
    },
    add: function(char) {
      if (this.text != null) {
        return this.text += char;
      } else {
        return this.text = char;
      }
    },
    clear: function() {
      return this.text = null;
    },
    out: function() {
      var text;
      text = this.text;
      this.clear();
      return text;
    }
  }),
  stack: proto["new"]({
    init: function() {
      this.raw = [];
      return this.now = 'empty';
    },
    push: function(item) {
      this.raw.push(item);
      return this.now = item.name;
    },
    pop: function() {
      this.raw.pop();
      if (this.raw.length > 0) {
        return this.now = this.raw[this.raw.length - 1].name;
      } else {
        return this.now = 'empty';
      }
    }
  }),
  indent: proto["new"]({
    init: function() {
      this.level = 0;
      return this.buffer = 0;
    },
    count: function() {
      return this.buffer += 1;
    },
    skip: function() {
      return this.buffer = 0;
    },
    read: function() {
      var diff, _ref;
      diff = this.buffer - this.level;
      _ref = [this.buffer, 0], this.level = _ref[0], this.buffer = _ref[1];
      if (Math.abs(diff % 2) === 1) {
        throw new Error('odd indentation!');
      }
      if (diff > 0) {
        return {
          type: 'indent',
          step: diff / 2
        };
      } else if (diff < 0) {
        return {
          type: 'dedent',
          step: -diff / 2
        };
      } else {
        return {
          type: 'plain'
        };
      }
    }
  }),
  ast: proto["new"]({
    init: function() {
      this.tree = [];
      return this.entry = [this.tree];
    },
    push: function(data) {
      return this.entry[this.entry.length - 1].push(data);
    },
    nest: function() {
      var new_entry;
      new_entry = [];
      this.entry[this.entry.length - 1].push(new_entry);
      return this.entry.push(new_entry);
    },
    ease: function() {
      return this.entry.pop();
    },
    newline: function() {
      this.ease();
      return this.nest();
    }
  }),
  folding: proto["new"]({
    init: function() {
      this.stack = [];
      this.exists = false;
      return this.level = 0;
    },
    add: function(object) {
      this.stack.push(object);
      this.level = object.level;
      return this.exists = true;
    },
    pop: function() {
      var object;
      object = this.stack.pop();
      this.exists = this.stack.length > 0;
      if (this.stack[0] != null) {
        this.level = this.stack[this.stack.length - 1].level;
      }
      return object;
    }
  })
};

/*
//@ sourceMappingURL=states.map
*/
